name: Deploy to VPS

# Runs automatically on every push to main.
# Secrets are injected over SSH — nothing sensitive ever touches the repo.

on:
  push:
    branches:
      - main
      - claude/genericize-readme-BrYAW  # temp: remove after merging to main
  workflow_dispatch: # Allow manual trigger from GitHub Actions tab

jobs:
  deploy:
    name: Deploy OpenClaw TradeDesk
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.2.0
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_USER_ID: ${{ secrets.TELEGRAM_USER_ID }}
          # Optional — leave unset to keep the default gateway token from openclaw.json.example
          OPENCLAW_GATEWAY_TOKEN: ${{ secrets.OPENCLAW_GATEWAY_TOKEN }}
          # Optional — override the domain used for the nginx TLS proxy (defaults to `hostname -f`)
          OPENCLAW_DOMAIN: ${{ secrets.OPENCLAW_DOMAIN }}
          # Optional — email for Let's Encrypt expiry notices; omit to register without email
          OPENCLAW_CERTBOT_EMAIL: ${{ secrets.OPENCLAW_CERTBOT_EMAIL }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: 22
          # Pass env vars into the remote shell session
          envs: ANTHROPIC_API_KEY,TELEGRAM_BOT_TOKEN,TELEGRAM_USER_ID,OPENCLAW_GATEWAY_TOKEN,OPENCLAW_DOMAIN,OPENCLAW_CERTBOT_EMAIL
          timeout: 300s
          script: |
            set -e

            WORKSPACE="$HOME/.openclaw/workspace"
            CONFIG="$HOME/.openclaw/openclaw.json"

            # ── 0. Bootstrap PATH (nvm / local bins) ────────────────────────────────
            # OpenClaw is Node.js-based and may be installed via nvm or npm global.
            # SSH sessions don't load .bashrc, so we source nvm manually.
            # openclaw >=2026.x requires Node >=22 — install it if missing (idempotent).
            export NVM_DIR="$HOME/.nvm"
            [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
            nvm install 22 2>/dev/null && nvm alias default 22 2>/dev/null || true
            export PATH="$HOME/.local/bin:$HOME/.npm/bin:/usr/local/bin:$PATH"

            # ── 1. Clone or pull the workspace ──────────────────────────────────────
            if [ -d "$WORKSPACE/.git" ]; then
              echo "==> Pulling latest changes into workspace..."
              git -C "$WORKSPACE" pull origin main
            else
              echo "==> Cloning repo into $WORKSPACE..."
              # Back up any existing (non-git) workspace so nothing is silently lost
              if [ -d "$WORKSPACE" ]; then
                BACKUP="${WORKSPACE}-backup-$(date +%Y%m%d%H%M%S)"
                echo "    Existing workspace moved to: $BACKUP"
                mv "$WORKSPACE" "$BACKUP"
              fi
              mkdir -p "$HOME/.openclaw"
              git clone https://github.com/Sensini7/OpenClaw-TradeDesk.git "$WORKSPACE"
            fi

            # ── 2. Inject secrets into openclaw config files ─────────────────────────
            # Done BEFORE installing OpenClaw so the installer finds a pre-existing
            # config and skips the interactive onboarding wizard (no TTY in CI).
            #
            # IMPORTANT: auth.profiles in openclaw.json is METADATA ONLY (provider +
            # mode). The actual API key must be written to auth-profiles.json, which
            # openclaw reads separately. Do NOT put the API key inside openclaw.json.
            echo "==> Writing $CONFIG from template..."
            mkdir -p "$HOME/.openclaw"
            cp "$WORKSPACE/openclaw.json.example" "$CONFIG"

            sed -i "s|YOUR_BOT_TOKEN_HERE|${TELEGRAM_BOT_TOKEN}|g"  "$CONFIG"
            sed -i "s|YOUR_TELEGRAM_USER_ID|${TELEGRAM_USER_ID}|g"  "$CONFIG"

            # Replace gateway token only if the secret is set (otherwise keep default)
            if [ -n "${OPENCLAW_GATEWAY_TOKEN}" ]; then
              sed -i "s|4bbaf7385f68a2d6914bdf661a52403ca213d2fd018ecbab|${OPENCLAW_GATEWAY_TOKEN}|g" "$CONFIG"
            fi

            # Fix workspace paths in config if running as a non-root user
            if [ "$HOME" != "/root" ]; then
              sed -i "s|/root/.openclaw/workspace|$HOME/.openclaw/workspace|g" "$CONFIG"
            fi

            # Write the actual API key to auth-profiles.json (separate from openclaw.json)
            # openclaw reads this file to resolve the "default" api_key profile.
            # Must be present in BOTH the main dir AND each agent's own dir —
            # agents look in their own agentDir first and fall back to the main dir
            # only if configured to do so; copying to all dirs is the safe default.
            AUTH_JSON="$HOME/.openclaw/auth-profiles.json"
            printf '{\n  "default": {\n    "apiKey": "%s"\n  }\n}\n' "${ANTHROPIC_API_KEY}" > "$AUTH_JSON"
            for agent in commander scout oracle trigger sentinel herald; do
              agent_dir="$HOME/.openclaw/agents/$agent/agent"
              mkdir -p "$agent_dir"
              cp "$AUTH_JSON" "$agent_dir/auth-profiles.json"
            done

            echo "==> Config and auth-profiles.json written."

            # ── 3. Install OpenClaw if not present ──────────────────────────────────
            # CI=1 tells the installer to run non-interactively.
            # The pre-written openclaw.json above means the installer skips the
            # interactive onboarding wizard.
            #
            # NOTE: The install.sh "Finalizing setup" step runs `openclaw` internally
            # and will exit 1 in no-TTY CI environments (/dev/tty unavailable).
            # The npm package itself is fully installed before that step — so we run
            # the installer in a subshell, suppress its exit code, then verify the
            # binary exists independently.
            if ! command -v openclaw &>/dev/null; then
              echo "==> OpenClaw not found — installing..."
              ( curl -fsSL https://openclaw.ai/install.sh | CI=1 bash ) 2>&1 || true

              # Re-source nvm so the newly installed bin/ is on PATH
              [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
              nvm use 22 2>/dev/null || true
              export PATH="$HOME/.local/bin:$HOME/.npm/bin:/usr/local/bin:$PATH"

              if ! command -v openclaw &>/dev/null; then
                echo "ERROR: OpenClaw installation failed — binary not found after install."
                exit 1
              fi
              echo "==> OpenClaw installed: $(openclaw --version 2>/dev/null || echo 'version unknown')"
            else
              echo "==> OpenClaw already installed: $(openclaw --version 2>/dev/null || echo 'version unknown')"
            fi

            # ── 4. Create intel/ symlinks (idempotent) ──────────────────────────────
            # Each agent workspace must have intel/ symlinked so agents can
            # read/write pipeline files without stepping outside their workspace.
            echo "==> Creating intel symlinks..."
            for agent in scout oracle trigger sentinel herald; do
              ln -sf "$WORKSPACE/intel" "$WORKSPACE/agents/$agent/intel"
              echo "    agents/$agent/intel -> $WORKSPACE/intel"
            done

            # ── 4.5. Migrate config to current schema ───────────────────────────────
            # doctor --fix auto-migrates stale fields (e.g. streaming boolean → enum,
            # missing telegram.enabled). Must run after openclaw is installed.
            echo "==> Running openclaw doctor --fix to migrate config..."
            openclaw doctor --fix 2>&1 || true

            # Enforce gateway config after doctor (doctor may reset these fields).
            #
            # bind=loopback: gateway listens on 127.0.0.1 only; nginx proxies from
            #   outside. Loopback connections are auto-approved for device pairing,
            #   which avoids the "pairing required" prompt in the Control UI.
            # trustedProxies: tells the gateway that nginx (127.0.0.1) is a trusted
            #   reverse proxy so it forwards the real client IP correctly.
            # allowedOrigins is set later in step 6 once the HTTPS domain is known.
            GW_TOKEN="${OPENCLAW_GATEWAY_TOKEN:-4bbaf7385f68a2d6914bdf661a52403ca213d2fd018ecbab}"
            if command -v jq &>/dev/null; then
              tmp=$(mktemp)
              jq --arg t "$GW_TOKEN" \
                '.gateway.bind = "loopback" | .gateway.trustedProxies = ["127.0.0.1"] | .gateway.auth = {"mode":"token","token":$t} | del(.gateway.controlUi.dangerouslyAllowHostHeaderOriginFallback)' \
                "$CONFIG" > "$tmp" && mv "$tmp" "$CONFIG"
              echo "    Gateway config enforced (bind=loopback, trustedProxies, auth=token) via jq."
            elif command -v python3 &>/dev/null; then
              python3 -c "import json,sys; cfg,tok=sys.argv[1],sys.argv[2]; d=json.load(open(cfg)); gw=d.setdefault('gateway',{}); gw['bind']='loopback'; gw['trustedProxies']=['127.0.0.1']; gw['auth']={'mode':'token','token':tok}; gw.setdefault('controlUi',{}).pop('dangerouslyAllowHostHeaderOriginFallback',None); open(cfg,'w').write(json.dumps(d,indent=2)); print('    Gateway config enforced (bind=loopback, trustedProxies, auth=token) via python3.')" "$CONFIG" "$GW_TOKEN"
            else
              echo "WARNING: neither jq nor python3 found — gateway config NOT enforced. Install jq on the VPS."
              exit 1
            fi

            # ── 5. Start/restart OpenClaw gateway ───────────────────────────────────
            # 'openclaw gateway restart' exits 0 even when the service is disabled
            # ("Gateway service disabled.") so we cannot rely on its exit code.
            # Instead: always ensure the daemon is installed first (idempotent),
            # then restart. The install step is a no-op when already installed.
            echo "==> Starting OpenClaw gateway..."
            openclaw gateway install 2>/dev/null || \
              openclaw gateway install-daemon 2>/dev/null || true

            if openclaw gateway restart 2>/dev/null; then
              echo "    Gateway restarted."
            else
              openclaw gateway start 2>/dev/null || {
                echo "ERROR: Could not start the OpenClaw gateway."
                echo "SSH into the server and run: openclaw gateway install && openclaw gateway start"
                exit 1
              }
            fi

            # ── 6. Set up nginx HTTPS reverse proxy ─────────────────────────────────
            # Browsers block crypto.subtle (required for Control UI device identity)
            # over plain HTTP on non-localhost origins.  nginx terminates TLS so the
            # dashboard works without a VPN or SSH tunnel.
            #
            # Domain strategy (in priority order):
            #   1. OPENCLAW_DOMAIN secret — use exactly as given.
            #   2. `hostname -f` — use if it has a public A record.
            #   3. <public-ip>.nip.io — free wildcard DNS that resolves <ip>.nip.io
            #      to <ip>; lets Let's Encrypt verify without any domain registration.
            #      Needed when the VPS hostname is PTR-only (no forward A record).
            DOMAIN="${OPENCLAW_DOMAIN:-$(hostname -f)}"
            NGINX_CONF=/etc/nginx/sites-available/openclaw
            echo "==> Setting up nginx HTTPS proxy..."

            # Install nginx + certbot if absent (idempotent)
            command -v nginx   &>/dev/null || DEBIAN_FRONTEND=noninteractive apt-get install -y -qq nginx
            command -v certbot &>/dev/null || DEBIAN_FRONTEND=noninteractive apt-get install -y -qq certbot python3-certbot-nginx

            # If no custom domain is set and the hostname has no public A record
            # (PTR-only hostnames are common on VPS providers), fall back to nip.io.
            if [ -z "${OPENCLAW_DOMAIN:-}" ] && ! getent hosts "$DOMAIN" &>/dev/null; then
              PUBLIC_IP=$(curl -4s --connect-timeout 5 ifconfig.me 2>/dev/null \
                || curl -4s --connect-timeout 5 icanhazip.com 2>/dev/null \
                || hostname -I | awk '{print $1}')
              DOMAIN="${PUBLIC_IP}.nip.io"
              echo "    hostname has no A record — using $DOMAIN (nip.io wildcard)."
            fi
            echo "    Domain: $DOMAIN"

            # Write baseline HTTP config; certbot will upgrade it to HTTPS in-place.
            # On re-deploys the baseline is re-written and certbot re-adds SSL.
            {
              echo "server {"
              echo "    listen 80;"
              echo "    server_name $DOMAIN;"
              echo "    location / {"
              echo "        proxy_pass http://127.0.0.1:18789;"
              echo "        proxy_http_version 1.1;"
              echo '        proxy_set_header Upgrade $http_upgrade;'
              echo '        proxy_set_header Connection "upgrade";'
              echo '        proxy_set_header Host $host;'
              echo '        proxy_set_header X-Real-IP $remote_addr;'
              echo "    }"
              echo "}"
            } > "$NGINX_CONF"
            ln -sf "$NGINX_CONF" /etc/nginx/sites-enabled/openclaw
            rm -f /etc/nginx/sites-enabled/default 2>/dev/null || true
            nginx -t && { systemctl is-active nginx &>/dev/null && systemctl reload nginx || systemctl start nginx; }

            # Obtain / renew TLS cert from Let's Encrypt
            CERTBOT_EMAIL_FLAG="--register-unsafely-without-email"
            [ -n "${OPENCLAW_CERTBOT_EMAIL:-}" ] && CERTBOT_EMAIL_FLAG="--email ${OPENCLAW_CERTBOT_EMAIL}"
            TLS_OK=false
            if certbot --nginx -d "$DOMAIN" --non-interactive --agree-tos \
                 $CERTBOT_EMAIL_FLAG --redirect 2>&1; then
              TLS_OK=true
              echo "    TLS certificate configured via Let's Encrypt."
            else
              echo "    WARNING: Let's Encrypt failed (port 80 blocked, DNS mismatch, or rate-limited)."
              echo "    Falling back to self-signed certificate."
              openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
                -keyout /etc/ssl/private/openclaw-selfsigned.key \
                -out /etc/ssl/certs/openclaw-selfsigned.crt \
                -subj "/CN=$DOMAIN" 2>/dev/null
              {
                echo "server {"
                echo "    listen 80; server_name $DOMAIN;"
                echo "    return 301 https://\$host\$request_uri;"
                echo "}"
                echo "server {"
                echo "    listen 443 ssl; server_name $DOMAIN;"
                echo "    ssl_certificate /etc/ssl/certs/openclaw-selfsigned.crt;"
                echo "    ssl_certificate_key /etc/ssl/private/openclaw-selfsigned.key;"
                echo "    location / {"
                echo "        proxy_pass http://127.0.0.1:18789;"
                echo "        proxy_http_version 1.1;"
                echo '        proxy_set_header Upgrade $http_upgrade;'
                echo '        proxy_set_header Connection "upgrade";'
                echo '        proxy_set_header Host $host;'
                echo '        proxy_set_header X-Real-IP $remote_addr;'
                echo "    }"
                echo "}"
              } > "$NGINX_CONF"
              nginx -t && systemctl reload nginx
              TLS_OK=true
            fi

            # Replace the interim dangerouslyAllowHostHeaderOriginFallback flag with
            # an explicit allowedOrigins list now that HTTPS + domain are confirmed.
            HTTPS_ORIGIN="https://$DOMAIN"
            python3 -c "import json; cfg='$CONFIG'; d=json.load(open(cfg)); gw=d.setdefault('gateway',{}); cui=gw.setdefault('controlUi',{}); cui['allowedOrigins']=['$HTTPS_ORIGIN']; cui.pop('dangerouslyAllowHostHeaderOriginFallback',None); open(cfg,'w').write(json.dumps(d,indent=2)); print('    controlUi.allowedOrigins set, dangerouslyAllowHostHeaderOriginFallback removed.')"
            openclaw gateway restart 2>/dev/null || true
            echo "==> nginx ready. Dashboard: https://$DOMAIN/"

            # ── 7. Health checks ────────────────────────────────────────────────────
            echo "==> Waiting for gateway to be ready..."
            sleep 5

            echo "--- Gateway status ---"
            openclaw gateway status

            echo "--- Agent list ---"
            openclaw agents list

            echo ""
            echo "Deployment complete."
            echo "Open: https://$DOMAIN/"
